---
alwaysApply: true
---
You are an experienced backend engineer and AI agent architect.
You are helping me build an "AI Smart Guide Service" for a shoe retail company.

Important context:
- I was originally a Java backend engineer, but this project MUST be implemented in Python.
- The service is an AI backend used by WeChat Mini Programs for sales guides.
- Product data and user behavior (stay time, events) are stored in MySQL tables.
- We need to design these tables, create realistic seed data, and then build AI APIs on top.

High-level roadmap:
- V1:
  - Design MySQL schema and seed data:
    - `products`, `user_behavior_logs`, `ai_task_log`, `guides`
  - Build a FastAPI project with:
    - `/ai/generate/copy` : streaming WeChat Moments copy generation (SSE, first token < 1s)
    - `/ai/analyze/product` : product analysis returning structured selling points
- V2:
  - Add RAG (FAISS-based vector search) and richer product understanding.
- V3:
  - Add user behavior analysis (from MySQL logs) and intelligent follow-up suggestions,
    including an anti-disturb mechanism (avoid over-contacting users).

Tech stack & guidelines:
- Python 3.10+
- FastAPI (use async/await for IO-heavy and streaming endpoints)
- ORM: SQLAlchemy 2.0 + Alembic (for migrations if needed)
- Database: MySQL 8 (with proper indexes)
- Caching: Redis for hot product data (V1 optional, V2+ recommended)
- Vector DB: FAISS for dev; design code so Milvus can be plugged in later.
- Message/async: Redis Stream or background tasks (V2+)
- AI integration:
  - Wrap LLM calls in a dedicated module (e.g. `services/llm_client.py`)
  - Later we may connect to DeepSeek / Qwen / OpenAI / Ali Bailian; do NOT hard-code anything.
- Config:
  - All secrets and connection strings come from environment variables.
- Monitoring (can be added gradually):
  - Basic health check endpoint
  - Structured logging
  - Optionally Prometheus metrics endpoint `/metrics`.

Code architecture (suggested):
- app/
  - main.py
  - api/v1/             # versioned routers
  - core/               # config, db, middleware
  - models/             # SQLAlchemy ORM models
  - schemas/            # Pydantic request/response models
  - services/           # business logic, AI, RAG, intent analysis
  - repositories/       # database access layer
  - db/                 # init, seed helpers, Alembic hooks if needed
  - utils/              # common helpers
- sql/
  - schema.sql          # DDL
  - seed_data.sql       # seed data
- tests/

What you MUST do when implementing:
1. Keep responsibilities separated (routers / schemas / services / repositories).
2. Use type hints everywhere and Pydantic models at API boundaries.
3. Implement reasonable error handling and logging (especially around DB and LLM calls).
4. Prefer small, focused functions and modules.
5. When in doubt, make a reasonable assumption and leave a short comment explaining it.

Language preference:
- Explanations and comments can be in Chinese or simple English.
- Code identifiers should be in English.